\documentclass[10pt, a4paper, hidelinks]{article}
\usepackage[paper=a4paper, left=2cm, right=2cm, bottom=2cm, top=3cm]{geometry} %ajustar márgnens
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{caratula}
\usepackage{enumitem} 
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[font=small,labelfont=bf]{caption}
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
%\usepackage{clrscode3e} Estilo Cormen
\usepackage[spanish,onelanguage,ruled,vlined,nofillcomment]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage[final]{pdfpages} % para agregar el enunciado
%%%%%%%%%%%%%% Formato de párrafos %%%%%%%%%%%%%%%%%%
\setlength{\parindent}{2em}
\setlength{\parskip}{3pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\usepackage{lastpage}
\setlength{\intextsep}{0.2cm}
\pagestyle{fancy}
\lhead{Sistemas Operativos}
\rhead{$1^{\mathrm{er}}$ cuatrimestre de 2018}

\LinesNumbered
\DontPrintSemicolon

\newcommand{\comp}[1]{$\mathcal{O}(#1)$}

%%%%%%%%%%%%%%%%%%% Macro para comentar codigo %%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\comentario}[1]{
\SetKwComment{Comment}{/* }{ */}
\textcolor{blue}{\Comment*[h]{{#1}}}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\materia{Sistemas Operativos}
\submateria{Primer cuatrimestre del 2018}
\titulo{Trabajo Práctico 2: \texttt{blockchain}}
\integrante{Budiño, Gabriel Fabricio}{046/16}{gabriel.f.budi@gmail.com} % obligatorio 
\integrante{Garro, Damián Eugenio}{354/16}{damian.garro.mst@gmail.com} % obligatorio 
\integrante{Rozenberg, Uriel Jonathan}{838/12}{rozenberguriel@gmail.com} % obligatorio 

\maketitle

\tableofcontents
\pagenumbering{gobble}

\pagebreak
\pagenumbering{arabic}
\cfoot{\thepage /\pageref{LastPage}}

\section{Introducción}
Para este trabajo se debía implementar una cadena de bloques ($blockchain$) utilizando la interfaz MPI con el objetivo de desarrollar conocimientos en sistemas distribuidos.

A continuación se presenta un breve resumén de la resolución de cada ejercicio así como de la experimentación realizada. El enunciado completo se encuentra en el Apéndice A.

\section{Resolución}
\subsection{Ejercicio 1}
La función \texttt{broadcast\_block} es la encargada de comunicar al resto de los nodos que se ha minado un bloque. El pseudocódigo de la misma es el siguiente:

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}
\SetAlgoLined
\Fn{broadcast\_block(bloque)}{
	\ForEach{nodo n distinto del comunicador}{
		enviar(bloque, n) \\
	}
}
\caption{\texttt{broadcast\_block}}
\end{algorithm}

Para referenciar a un proceso ($nodo$) usamos su \texttt{rank} dentro del communicator global \texttt{MPI\_COMM\_WORLD}. Contamos con las variables \texttt{mpi\_rank} y \texttt{total\_nodes}. Así, para cada \texttt{mpi\_rank} + 1 $\leq i \leq$ \texttt{mpi\_rank} + \texttt{total\_nodes}, definimos $destino$ como $i$ $mod$ \texttt{total\_nodes} y enviamos el mensaje usando \texttt{MPI\_Send} con $destino$, $bloque$ y el tag \texttt{TAG\_NEW\_BLOCK} como parámetros.
 
\subsection{Ejercicio 2}
\textbf{TODO: Resumen ejercicio 2. Lo pase por ahora porque lo estaban modificando}
\subsection{Ejercicio 3}
Cuando un nodo mine un nuevo bloque y le avise al resto, estos deberán decidir si agregarlo o no a la cadena. Para eso se utiliza la función \texttt{validate\_block\_for\_chain}, la cual debía cumplir con el consenso definido en el enunciado. Su pseudocódigo es el siguiente:

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}
\SetAlgoLined
\Fn{validate\_block\_for\_chain(rBlock, status)}{
	agrego $rBlock$ al diccionario \\
	\comentario{1er item del consenso} \\
	\If{\texttt{valid\_new\_block(rBlock)}}{
		\comentario{2do item del consenso} \\
		\If{rBlock.indice = 1 y \texttt{last\_block\_in\_chain}.indice = 0}{
			\texttt{last\_block\_in\_chain} $\leftarrow$ $rBlock$ \\
			devolver \texttt{true}
		}
		\If{rBlock.indice = \texttt{last\_block\_in\_chain}.indice + 1}{
			\comentario{3er item del consenso} \\
			\If{anteior de rBlock = anterior de \texttt{last\_block\_in\_chain}}{
				\texttt{last\_block\_in\_chain} $\leftarrow$ $rBlock$ \\
				devolver \texttt{true} \\			
			} \comentario{4to item del consenso} \\ 
			\Else {
				$res$ $\leftarrow$ \texttt{verificar\_y\_migrar\_cadena}($rBlock$, $status$) \\
				devolver $res$
			}
		}
		\comentario{5to item del consenso} \\
		\If{rBlock.indice = \texttt{last\_block\_in\_chain}.indice}{
			devolver \texttt{false}		
		}
		\If{rBlock.indice $<$ \texttt{last\_block\_in\_chain}.indice}{
			devolver \texttt{false}		
		}
		\comentario{6to item del consenso} \\
		\If{rBlock.indice $>$ \texttt{last\_block\_in\_chain}.indice}{
			$res$ $\leftarrow$ \texttt{verificar\_y\_migrar\_cadena}($rBlock$, $status$) \\
			devolver $res$	
		}
	}
}
\caption{\texttt{validate\_block\_for\_chain}}
\end{algorithm}

\textbf{TODO: Hablar de las race conditions y quizás del if que no esta en el consenso}
 
\subsection{Ejercicio 4}
Llegado al caso donde un nodo deba migrar a la $blockchain$ de otro, se utilizará la función\texttt{verificar\_y\_migrar\_cadena}. La misma debía cumplir con el protocolo descripto en el enunciado. A continuación se muestra su pseudocódigo:

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}
\SetAlgoLined
\Fn{\texttt{verificar\_y\_migrar\_cadena}(rBlock, status)}{
	\comentario{Solicitud de los bloques} \\	
	\texttt{MPI\_Send}($rBlock$, $status.mpi\_source$, \texttt{TAG\_CHAIN\_HASH}) \\
	\comentario{Recepción de los bloques} \\
	$blockchain$ $\leftarrow$ nuevo arreglo de bloques \\
	\texttt{MPI\_Recv}($blockchain$, $status.mpi\_source$, \texttt{TAG\_CHAIN\_RESPONSE}) \\
	\comentario{1er item del protocolo} \\
	\If{$blockchain$[0].indice $\neq$ rBlock.indice $\lor$ $blockchain$[0].hash $\neq$ rBlock.hash}{
		borrar $blockchain$ \\
		devolver \texttt{false}	
	}
	\comentario{2do item del protocolo} \\
	\If{rBlock.hash $\neq$ \texttt{block\_to\_hash($blockchain$[0])}}{
		borrar $blockchain$ \\
		devolver \texttt{false}	
	}
	\ForEach{bloque b en blockchain}{
		$b'$ $\leftarrow$ siguiente del bloque b en blockchain \\
		\comentario{3er item del protocolo} \\		
		\If{hash del anterior de b $\neq$ b'.hash}{
			borrar $blockchain$ \\
			devolver \texttt{false}			
		}
		\comentario{4to item del protocolo} \\
		\If{b.indice $\neq$ b'.indice}{
			borrar $blockchain$ \\
			devolver \texttt{false}		
		}	
	}
	$u$ $\leftarrow$ ultimo bloque de $blockchain$ \\
	\If{ningún b $\in$ blockchain está en el diccionario $\land$ $u$.indice $\neq$ 1}{
		borrar $blockchain$ \\
		devolver \texttt{false}		
	}
	\ForEach{bloque b $\in$ blockchain}{
		\If{\texttt{valid\_new\_block($b$)}}{
			agregar $b$ al diccionario \\		
		} \Else {
			borrar $blockchain$ \\
			devolver \texttt{false}		
		}	
	}
}
\caption{\texttt{verificar\_y\_migrar\_cadena}}
\end{algorithm}

\subsection{Ejercicio 5}

\section{Experimentación}


\newpage
\includepdf[scale=0.75,pages=1,pagecommand=\section{Apéndices}
\subsection{Apéndice A - Enunciado}]{../enunciado.pdf}
\includepdf[scale=0.75,pages=2-,pagecommand=]{../enunciado.pdf}

\subsection{Apéndice B - Aclaraciones}

\end{document}

