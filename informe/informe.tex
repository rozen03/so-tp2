\documentclass[10pt, a4paper, hidelinks]{article}
\usepackage[paper=a4paper, left=2cm, right=2cm, bottom=2cm, top=3cm]{geometry} %ajustar m�rgnens
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{caratula}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[font=small,labelfont=bf]{caption}
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
%\usepackage{clrscode3e} Estilo Cormen
\usepackage[spanish,onelanguage,ruled,vlined,nofillcomment]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage[final]{pdfpages} % para agregar el enunciado
%%%%%%%%%%%%%% Formato de p�rrafos %%%%%%%%%%%%%%%%%%
\setlength{\parindent}{2em}
\setlength{\parskip}{3pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\usepackage{lastpage}
\setlength{\intextsep}{0.2cm}
\pagestyle{fancy}
\lhead{Sistemas Operativos}
\rhead{$1^{\mathrm{er}}$ cuatrimestre de 2018}

\LinesNumbered
\DontPrintSemicolon

\newcommand{\comp}[1]{$\mathcal{O}(#1)$}

%%%%%%%%%%%%%%%%%%% Macro para comentar codigo %%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\comentario}[1]{
\SetKwComment{Comment}{/* }{ */}
\textcolor{blue}{\Comment*[h]{{#1}}}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\materia{Sistemas Operativos}
\submateria{Primer cuatrimestre del 2018}
\titulo{Trabajo Pr�ctico 2: \texttt{blockchain}}
\integrante{Budi�o, Gabriel Fabricio}{046/16}{gabriel.f.budi@gmail.com} % obligatorio
\integrante{Garro, Dami�n Eugenio}{354/16}{damian.garro.mst@gmail.com} % obligatorio
\integrante{Rozenberg, Uriel Jonathan}{838/12}{rozenberguriel@gmail.com} % obligatorio

\maketitle

\tableofcontents
\pagenumbering{gobble}

\pagebreak
\pagenumbering{arabic}
\cfoot{\thepage /\pageref{LastPage}}

\section{Introducci�n}
Para este trabajo se deb�a implementar una cadena de bloques ($blockchain$) utilizando la interfaz MPI con el objetivo de desarrollar conocimientos en sistemas distribuidos.

A continuaci�n se presenta un breve resum�n de la resoluci�n de cada ejercicio as� como de la experimentaci�n realizada. El enunciado completo se encuentra en el Ap�ndice A, donde puede consultarse tanto la informaci�n de las estructuras usadas como los enunciados a los que responden las siguientes secciones del informe.

\section{Resoluci�n}
\subsection{Ejercicio 1}
La funci�n \texttt{broadcast\_block} es la encargada de, al momento en que un nodo mina exitosamente un bloque, comunic�rselo al resto. El pseudoc�digo de la misma es el siguiente:

\begin{algorithm}[H]
\SetKwProg{Fn}{Funci�n}{}{fin}
\SetAlgoLined
\Fn{broadcast\_block(bloque)}{
	\ForEach{nodo n distinto del productor del bloque}{
		\texttt{MPI\_Send}($bloque$, $n.rank$, \texttt{TAG\_NEW\_BLOCK}) \\
	}
}
\caption{\texttt{broadcast\_block}}
\end{algorithm}

Para referenciar a un proceso ($nodo$) usamos su \texttt{rank} dentro del communicator global \texttt{MPI\_COMM\_WORLD}. Cada nodo metiene las variables \texttt{mpi\_rank} y \texttt{total\_nodes}. As�, para cada 1 $\leq i \leq$ \texttt{total\_nodes}, definimos $destino$ como $(i + \texttt{mpi\_rank})$ $mod$ \texttt{total\_nodes} y enviamos el mensaje usando \texttt{MPI\_Send} con $destino$, $bloque$ y el tag \texttt{TAG\_NEW\_BLOCK} como par�metros (principalmente). Es decir, enviamos el bloque desde el nodo siguiente al que lo min� en adelante, asegur�ndonos as� que todos los nodos env�en mensajes en distinto orden.

\subsection{Ejercicio 2}
Para la resuluci�n de este ejercicio, se agreg� a la informaci�n que mantiene cada nodo un bool at�mico \texttt{probando}. Adem�s, se implementaron las funciones \texttt{lock} y \texttt{unlock} como se muestran a continuaci�n:

\begin{algorithm}[H]
\SetKwProg{Fn}{Funci�n}{}{fin}
\SetAlgoLined
\Fn{lock()}{
	$expected$ $\leftarrow$ \texttt{false} \\
	\While{$\lnot$ \texttt{probando}.compare\_exchange\_weak($expected$, \texttt{true})}{
		$expected$ $\leftarrow$ \texttt{false}
	}
}
\caption{\texttt{lock}}
\end{algorithm}

\begin{algorithm}[H]
\SetKwProg{Fn}{Funci�n}{}{fin}
\SetAlgoLined
\Fn{unlock()}{
	\texttt{probando} $\leftarrow$ \texttt{false}
}
\caption{\texttt{unlock}}
\end{algorithm}

Se ped�a modificar las funciones \texttt{node} y \texttt{proof\_of\_work} para evitar $race$ $conditinos$. A continuaci�n, se muestra el pseudoc�digo de la parte implementada del m�todo \texttt{node}:

\begin{algorithm}[H]
\SetKwProg{Fn}{Funci�n}{}{fin}
\SetAlgoLined
\Fn{node()}{
	\comentario{Tomar valor de mpi\_rank y de total\_nodes} \\
	\comentario{Inicializaci�n del primer bloque} \\
	\comentario{Crear thread para minar} \\
	crear nuevo thread con la funci�n \texttt{proof\_of\_work} como punto de inicio \\
	\While{\texttt{true}}{
		$block$ $\leftarrow$ nuevo bloque \\
		\comentario{Recibir mensajes de otros nodos} \\
		$status$ $\leftarrow$ \texttt{MPI\_Probe()} \\
		\comentario{Si es un mensaje de nuevo bloque} \\
		\If{status.tag = \texttt{TAG\_NEW\_BLOCK}}{
		$status$ $\leftarrow$ \texttt{MPI\_Recv($block$)} \\
			\texttt{lock()} \\
			\texttt{validate\_block\_for\_chain}($block$, $status$) \\
			\texttt{unlock()}
		} \comentario{Si es un mensaje de pedido de cadena} \\
		\ElseIf{status.tag = TAG\_CHAIN\_HASH}{
		$status$ $\leftarrow$ \texttt{MPI\_Recv($block_hash$)} \\
			\texttt{mandar\_cadena}($block_hash$, $status$) \\
		}
	}
}
\caption{\texttt{node}}
\end{algorithm}

En cuanto a la funci�n \texttt{proof\_of\_work}, una vez que se consigue la cantidad de ceros requerida por la dificultad configurada, se ejecuta un bloque que inicialmente verifica que no haya cambiado \texttt{last\_block\_in\_chain} y finalmente llama a \texttt{broadcast\_block} para comunicar que se ha minado un bloque. Consideramos estas dos acciones como los l�mites de la secci�n cr�tica, as� que llamamos a \texttt{lock()} inmediatamente antes de la primera y a \texttt{unlock()} inmediatamente despu�s de la segunda, de esta forma evitamos \textit{race conditions} porque la cadena del nodo solo puede ser modificada por un \textit{thread} al mismo tiempo

\textbf{TODO: Detallar ac� \texttt{mandar\_cadena}? Pero antes ver lo de recibir hash en vez de bloque. Ver si hacemos lo de probe, el pseudc�digo puede ser m�s pseudo.}

\subsection{Ejercicio 3}
Cuando un nodo mine un nuevo bloque y le avise al resto, estos deber�n decidir si agregarlo o no a la cadena. Para eso se utiliza la funci�n \texttt{validate\_block\_for\_chain}, la cual deb�a cumplir con el consenso definido en la secci�n 3 del enunciado. Su pseudoc�digo es el siguiente:

\begin{algorithm}[H]
\SetKwProg{Fn}{Funci�n}{}{fin}
\SetAlgoLined
\Fn{validate\_block\_for\_chain(rBlock, status)}{
	\If{\texttt{valid\_new\_block(rBlock)}}{
		agrego $rBlock$ a \texttt{node\_blocks} \\
		\If{rBlock.indice = 1 y \texttt{last\_block\_in\_chain}.indice = 0}{
			\comentario{2do item del consenso} \\
			\texttt{last\_block\_in\_chain} $\leftarrow$ $rBlock$ \\
			devolver \texttt{true}
		}
		\If{rBlock.indice = \texttt{last\_block\_in\_chain}.indice + 1}{
			\uIf{anterior de rBlock = anterior de \texttt{last\_block\_in\_chain}}{
				\comentario{3er item del consenso} \\
				\texttt{last\_block\_in\_chain} $\leftarrow$ $rBlock$ \\
				devolver \texttt{true} \\
			} \Else {
				\comentario{4to item del consenso} \\
				devolver \texttt{verificar\_y\_migrar\_cadena}($rBlock$, $status$)
			}
		}
		\If{rBlock.indice = \texttt{last\_block\_in\_chain}.indice}{
			\comentario{5to item del consenso} \\
			devolver \texttt{false}
		}
		\If{rBlock.indice $<$ \texttt{last\_block\_in\_chain}.indice}{
			devolver \texttt{false}
		}
		\If{rBlock.indice $>$ \texttt{last\_block\_in\_chain}.indice}{
			\comentario{6to item del consenso} \\
			devolver \texttt{verificar\_y\_migrar\_cadena}($rBlock$, $status$) \\
		}
	}
	\comentario{1er item del consenso} \\
	devolver \textit{false}
}
\caption{\texttt{validate\_block\_for\_chain}}
\end{algorithm}

Esta funci�n puede modificar \texttt{last\_block\_in\_chain} a salvo de \textit{race conditions} porque se llama dentro de la secci�n cr�tica que definimos en el ejercicio anterior.

\textbf{TODO: Hablar quiz�s del if que no esta en el consenso.}

\subsection{Ejercicio 4}
Llegado al caso donde un nodo deba migrar a la $blockchain$ de otro, se utilizar� la funci�n \texttt{verificar\_y\_migrar\_cadena}. La misma deb�a cumplir con el protocolo descripto en la secci�n 4 del enunciado. A continuaci�n se muestra su pseudoc�digo:

\begin{algorithm}[H]
\SetKwProg{Fn}{Funci�n}{}{fin}
\SetAlgoLined
\Fn{\texttt{verificar\_y\_migrar\_cadena}(rBlock, status)}{
	\comentario{Solicitud de los bloques} \\
	\texttt{MPI\_Send}($rBlock$, $status.mpi\_source$, \texttt{TAG\_CHAIN\_HASH}) \\
	\comentario{Recepci�n de los bloques} \\
	$blockchain$ $\leftarrow$ nuevo arreglo de bloques \\
	\texttt{MPI\_Recv}($blockchain$, $status.mpi\_source$, \texttt{TAG\_CHAIN\_RESPONSE}) \\
	\comentario{1er item del protocolo} \\
	\If{el primer elemento de $blockchain$ tiene �ndice o hash distinto al pedido}{
		devolver \texttt{false}
	}
	\comentario{2do item del protocolo} \\
	\If{rBlock.hash $\neq$ \texttt{block\_to\_hash($blockchain$[0])}}{
		devolver \texttt{false}
	}
	\ForEach{bloque b $\in$ blockchain}{
		$b'$ $\leftarrow$ siguiente del bloque b en blockchain \\
		\comentario{3er item del protocolo} \\
		\If{hash del anterior de b $\neq$ b'.hash}{
			devolver \texttt{false}
		}
		\comentario{4to item del protocolo} \\
		\If{b.indice $\neq$ b'.indice + 1}{
			devolver \texttt{false}
		}
	}
	$u$ $\leftarrow$ ultimo bloque de $blockchain$ \\
	\If{ning�n b $\in$ blockchain est� en el diccionario $\land$ $u$.indice $\neq$ 1}{
		devolver \texttt{false}
	}
	\ForEach{bloque b $\in$ blockchain}{
		\uIf{\texttt{valid\_new\_block($b$)}}{
			agregar $b$ al diccionario \\
		} \Else {
			devolver \texttt{false}
		}
	}
	\texttt{last\_block\_in\_chain} $\leftarrow$ $blockchain$[0] \\
	devolver \texttt{true}
}
\caption{\texttt{verificar\_y\_migrar\_cadena}}
\end{algorithm}

Esta funci�n se llama solo desde la \texttt{validate\_block\_for\_chain}, la cual ya dijimos que se ejecuta dentro de la secci�n cr�tica, as� que no hay \textit{race conditions} con el \textit{thread} que mina bloques.

\textbf{TODO Sacar \texttt{valid\_new\_block($b$)}? Igual habr�a que revisar que los hashes sean correctos en alg�n lugar? No dice nada en el protocolo creo. Mensaje con hash en vez de bloque.}

\subsection{Ejercicio 5}

\section{Experimentaci�n}


\newpage
\includepdf[scale=0.75,pages=1,pagecommand=\section{Ap�ndices}
\subsection{Ap�ndice A - Enunciado}]{../enunciado.pdf}
\includepdf[scale=0.75,pages=2-,pagecommand=]{../enunciado.pdf}

\subsection{Ap�ndice B - Aclaraciones}

\end{document}
